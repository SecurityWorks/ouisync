use crate::crypto::{cipher::SecretKey, Password, PasswordSalt};
use ouisync_macros::api;
#[cfg(test)]
use rand::{CryptoRng, Rng};
use serde::{Deserialize, Serialize};

/// Type of secret to unlock a repository.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[api]
pub enum LocalSecret {
    /// Password provided by the user
    Password(Password),
    /// Secret key generated by secure means (e.g., crypto-secure RNG, KDF, ...)
    SecretKey(SecretKey),
}

#[cfg(test)]
impl LocalSecret {
    /// Generates random local secret containing a secret key.
    pub fn random() -> Self {
        Self::SecretKey(SecretKey::random())
    }

    /// Generates random local secret containing a secret key using the provided RNG.
    pub fn generate<R: Rng + CryptoRng + ?Sized>(rng: &mut R) -> Self {
        Self::SecretKey(SecretKey::generate(rng))
    }
}

/// Used to set or change the read or write local secret of a repository.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[api]
pub enum SetLocalSecret {
    /// Password provided by the user
    Password(Password),
    /// Use to directly (without doing password hashing) set the `SecretKey` and `PasswordSalt` for
    /// read or write access.
    KeyAndSalt { key: SecretKey, salt: PasswordSalt },
}

#[cfg(test)]
impl SetLocalSecret {
    /// Generates random secret key and salt.
    pub fn random() -> Self {
        Self::KeyAndSalt {
            key: SecretKey::random(),
            salt: PasswordSalt::random(),
        }
    }
}

#[cfg(test)]
impl From<SetLocalSecret> for LocalSecret {
    fn from(local: SetLocalSecret) -> Self {
        match local {
            SetLocalSecret::Password(pwd) => Self::Password(pwd),
            SetLocalSecret::KeyAndSalt { key, .. } => Self::SecretKey(key),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn serialize_deserialize_bincode() {
        let orig = LocalSecret::Password("mellon".to_string().into());
        let expected_serialized_hex = "0000000006000000000000006d656c6c6f6e";

        let serialized = bincode::serialize(&orig).unwrap();
        assert_eq!(hex::encode(&serialized), expected_serialized_hex);

        let deserialized: LocalSecret = bincode::deserialize(&serialized).unwrap();
        assert_eq!(&deserialized, &orig);
    }

    #[test]
    fn serialize_deserialize_msgpack() {
        let orig = LocalSecret::Password("mellon".to_string().into());
        let expected_serialized_hex = "81a850617373776f7264a66d656c6c6f6e";

        let serialized = rmp_serde::to_vec(&orig).unwrap();
        assert_eq!(hex::encode(&serialized), expected_serialized_hex);

        let deserialized: LocalSecret = rmp_serde::from_slice(&serialized).unwrap();
        assert_eq!(&deserialized, &orig);
    }
}
