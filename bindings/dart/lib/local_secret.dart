part of 'ouisync.dart';

/*

// `LocalSecret` is used to encrypt and decrypt "global" read and write keys
// stored inside repositories which are consequently used to encrypt, decrypt
// and sign repository data.
//
// There may be two `LocalSecrets`, one for decrypting the global read and one
// decrypting the global write keys. Note the that decrypting the global write
// key will enable repository reading as well because the global read key is
// derived from the global write key.
//
// When opening a repository with a `LocalSecret` the library will attempt to
// gain the highest possible access. That is, it will use the local secret to
// decrypt the global write key first and, if that fails, it'll attempt to
// decrypt the global read key.
//
// `LocalSecret` can be either a `LocalPassword` or a `LocalSecretKey`. In case
// a `LocalPassword` is provided to the library, it is internally converted to
// `LocalSecretKey` using a KDF and a `PasswordSalt`.  Ouisync uses two
// `PasswordSalt`s one for the "read" and one for the "write" local secret keys
// and they are stored inside each repository database individually.
sealed class LocalSecret {
  Object? encode();

  @override
  String toString();
}

sealed class SetLocalSecret {
  Object? encode();

  LocalSecret toLocalSecret();

  @override
  String toString();
}

// A user provided password used to encrypt individual repository databases
class LocalPassword implements LocalSecret, SetLocalSecret {
  final String string;

  LocalPassword(this.string);

  int get length => string.length;
  bool get isEmpty => string.isEmpty;

  @override
  LocalSecret toLocalSecret() {
    return this;
  }

  @override
  Object? encode() => {'password': string};

  // Discourage from writing local secret into the log.
  @override
  String toString() => "LocalPassword(***)";

  @override
  bool operator ==(Object other) {
    if (other is! LocalPassword) return false;
    return string == other.string;
  }

  @override
  int get hashCode => string.hashCode;
}

// Key generated by Argon2 KDF from a `LocalPassword` and a `PasswordSalt`. The
// salt is stored in the per-repository database.
class LocalSecretKey implements LocalSecret {
  // 256-bit as used by the Rust ChaCha20 implementation Ouisync is using.
  static const sizeInBytes = 32;

  final Uint8List _bytes;

  LocalSecretKey(this._bytes);

  Uint8List get bytes => _bytes;

  static LocalSecretKey random() {
    return LocalSecretKey(_randomBytes(sizeInBytes));
  }

  @override
  Object? encode() => {'secret_key': _bytes};

  // Discourage from writing local secret into the log.
  @override
  String toString() => "LocalSecretKey(***)";
}

class LocalSecretKeyAndSalt implements SetLocalSecret {
  // 256-bit as used by the Rust ChaCha20 implementation Ouisync is using.
  static const sizeInBytes = 32;

  final LocalSecretKey key;
  final PasswordSalt salt;

  LocalSecretKeyAndSalt(this.key, this.salt);

  static LocalSecretKeyAndSalt random() =>
      LocalSecretKeyAndSalt(LocalSecretKey.random(), PasswordSalt.random());

  @override
  LocalSecret toLocalSecret() {
    return key;
  }

  @override
  Object? encode() => {
        'key_and_salt': {'key': key.bytes, 'salt': salt.bytes}
      };

  // Discourage from writing local secret into the log.
  @override
  String toString() => "LocalSecretKeyAndSalt(***, $salt)";
}

class PasswordSalt {
  // https://docs.rs/argon2/latest/argon2/constant.RECOMMENDED_SALT_LEN.html
  static const sizeInBytes = 16;

  final Uint8List _bytes;

  PasswordSalt(this._bytes);

  Uint8List get bytes => _bytes;

  static PasswordSalt random() {
    return PasswordSalt(_randomBytes(sizeInBytes));
  }

  String toBase64() => base64.encode(_bytes);

  static PasswordSalt fromBase64(String salt64) =>
      PasswordSalt(base64.decode(salt64));

  // Discourage from writing local secret into the log.
  @override
  String toString() => "PasswordSalt(${base64.encode(_bytes)})";
}

Uint8List _randomBytes(int size) {
  final random = Random.secure();
  Uint8List bytes = Uint8List(size);
  for (int i = 0; i < size; i++) {
    bytes[i] = random.nextInt(256);
  }
  return bytes;
}
*/
